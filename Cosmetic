local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
_G.Visuals_Color = Color3.fromRGB(255, 255, 255)
_G.Settings = {
    ChinaHat = {
        Enabled = false,
        Color = _G.Visuals_Color,
        Transparency = 0.8,
        Size = Vector3.new(2, 1, 2),
        PositionOffset = Vector3.new(0, 0.5, 0)
    },
    Trails = {
        Enabled = false,
        Color = _G.Visuals_Color,
        Transparency = 0.5
    },
    BulletTracer = {
        Enabled = false,
        View = "Counter Blox",
        Transparency = 0.5,
        Color = Color3.fromRGB(255, 255, 255),
        Lifetime = 3,
        Speed = 900,
        Scale = NumberSequence.new(0.209)
    },
    ThirdPerson = {
        Enabled = false,
        View = "Default",
        Distance = 200
    },
    FovCustom = {
        Enabled = false,
        Value = 70
    },
    Scrench = {
        Enabled = false,
        Resolution = 0.65
    },
    WeaphonMaterial = {
        Enabled = false,
        View = "Default",
        Material = "Neon",
        Color = Color3.fromRGB(255, 255, 255),
        RGB = false
    },
    PlayerMaterial = {
        Enabled = false,
        Material = "Neon",
        Color = Color3.fromRGB(255, 255, 255),
        TeamCheck = false
    }
}
_G.hatData = {
    meshPart = nil,
    headAttachment = nil,
    meshAttachment = nil,
    weld = nil
}
_G.trailData = {
    trails = {}
}
local origCameraSettings = {
    captured = false,
    MaxZoom = nil,
    MinZoom = nil,
    Mode = nil,
    FOV = nil
}
local function captureOriginalCamera()
    local Camera = Workspace.CurrentCamera
    if not origCameraSettings.captured and LocalPlayer and Camera then
        origCameraSettings.MaxZoom = LocalPlayer.CameraMaxZoomDistance
        origCameraSettings.MinZoom = LocalPlayer.CameraMinZoomDistance
        origCameraSettings.Mode = LocalPlayer.CameraMode
        origCameraSettings.FOV = Camera.FieldOfView
        origCameraSettings.captured = true
    end
end
_G.removeHat = function()
    if _G.hatData.meshPart then
        _G.hatData.meshPart:Destroy()
        _G.hatData.meshPart = nil
    end
    if _G.hatData.headAttachment then
        _G.hatData.headAttachment:Destroy()
        _G.hatData.headAttachment = nil
    end
    if _G.hatData.meshAttachment then
        _G.hatData.meshAttachment:Destroy()
        _G.hatData.meshAttachment = nil
    end
    if _G.hatData.weld then
        _G.hatData.weld:Destroy()
        _G.hatData.weld = nil
    end
end
_G.createHat = function(head)
    if not head then return end
    _G.removeHat()
    _G.hatData.meshPart = Instance.new("MeshPart")
    _G.hatData.meshPart.Name = "ChinaHat"
    _G.hatData.meshPart.Size = _G.Settings.ChinaHat.Size
    _G.hatData.meshPart.Anchored = false
    _G.hatData.meshPart.CanCollide = false
    _G.hatData.meshPart.Material = Enum.Material.Neon
    _G.hatData.meshPart.Color = _G.Settings.ChinaHat.Color
    _G.hatData.meshPart.Transparency = _G.Settings.ChinaHat.Transparency
    _G.hatData.meshPart.RenderFidelity = Enum.RenderFidelity.Automatic
    _G.hatData.meshPart.MeshId = "rbxassetid://1033714"
    _G.hatData.headAttachment = Instance.new("Attachment")
    _G.hatData.headAttachment.Parent = head
    _G.hatData.meshAttachment = Instance.new("Attachment")
    _G.hatData.meshAttachment.Parent = _G.hatData.meshPart
    _G.hatData.weld = Instance.new("WeldConstraint")
    _G.hatData.weld.Part0 = head
    _G.hatData.weld.Part1 = _G.hatData.meshPart
    _G.hatData.weld.Parent = _G.hatData.meshPart
    _G.hatData.meshPart.CFrame = head.CFrame * CFrame.new(_G.Settings.ChinaHat.PositionOffset)
    _G.hatData.meshPart.Parent = Workspace
end
_G.clearTrails = function()
    for _, trail in pairs(_G.trailData.trails) do
        if trail and trail.Parent then
            trail:Destroy()
        end
    end
    _G.trailData.trails = {}
end
_G.createTrail = function(part)
    if not part then return end
    local trail = Instance.new("Trail")
    local attachment0 = Instance.new("Attachment")
    local attachment1 = Instance.new("Attachment")
    attachment0.Parent = part
    attachment1.Parent = part
    attachment1.Position = Vector3.new(0, 0.5, 0)
    trail.Attachment0 = attachment0
    trail.Attachment1 = attachment1
    trail.LightEmission = 1
    trail.Color = ColorSequence.new(_G.Settings.Trails.Color)
    trail.Transparency = NumberSequence.new(_G.Settings.Trails.Transparency)
    trail.Lifetime = 0.5
    trail.Enabled = true
    trail.Parent = part
    table.insert(_G.trailData.trails, trail)
    return trail
end
_G.initializeTrails = function(character)
    if not character then return end
    _G.clearTrails()
    if _G.Settings.Trails.Enabled then
        local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
        if torso then
            _G.createTrail(torso)
        end
    end
end
_G.updateHatProperties = function()
    if _G.hatData.meshPart then
        _G.hatData.meshPart.Color = _G.Settings.ChinaHat.Color
        _G.hatData.meshPart.Transparency = _G.Settings.ChinaHat.Transparency
        _G.hatData.meshPart.Size = _G.Settings.ChinaHat.Size
    end
end
_G.updateTrailProperties = function()
    for _, trail in pairs(_G.trailData.trails) do
        if trail and trail.Parent then
            trail.Color = ColorSequence.new(_G.Settings.Trails.Color)
            trail.Transparency = NumberSequence.new(_G.Settings.Trails.Transparency)
        end
    end
end
local function spawnBulletTrail(originCFrame, view)
    local TRACER_COLOR = _G.Settings.BulletTracer.Color
    local TRACER_LIFETIME = _G.Settings.BulletTracer.Lifetime
    local TRACER_SPEED = _G.Settings.BulletTracer.Speed
    local scale = _G.Settings.BulletTracer.Scale
    if view == "Arsenal" then
        scale = NumberSequence.new(0.35)
        TRACER_SPEED = 1400
    end
    local bullet = Instance.new("Part")
    bullet.Size = Vector3.new(1, 0.5, 1.1)
    bullet.Material = Enum.Material.Neon
    bullet.Color = TRACER_COLOR
    bullet.Anchored = false
    bullet.CanCollide = false
    bullet.CastShadow = false
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Parent = bullet
    bullet.CFrame = originCFrame
    bv.Velocity = originCFrame.LookVector * TRACER_SPEED
    bullet.Parent = Workspace
    local a0 = Instance.new("Attachment", bullet)
    a0.Position = Vector3.new(0, 0, -0.15)
    local a1 = Instance.new("Attachment", bullet)
    a1.Position = Vector3.new(0, 0, 0.15)
    local trail = Instance.new("Trail")
    trail.Attachment0 = a0
    trail.Attachment1 = a1
    trail.FaceCamera = true
    trail.Lifetime = TRACER_LIFETIME
    trail.LightEmission = 1
    trail.LightInfluence = 0
    trail.WidthScale = scale
    trail.Transparency = NumberSequence.new(_G.Settings.BulletTracer.Transparency)
    trail.Color = ColorSequence.new(TRACER_COLOR)
    trail.Parent = bullet
    task.delay(TRACER_LIFETIME, function()
        if bullet then bullet:Destroy() end
    end)
end
local tracerRemoteMapping = {
    ["Counter Blox"] = {"ReplicateShot"},
    ["Arsenal"] = {"FireBullet"}
}
local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    if method == "FireServer" and _G.Settings.BulletTracer.Enabled then
        local name = tostring(self)
        local view = _G.Settings.BulletTracer.View
        if type(view) == "table" then
            view = view[1]
        end
        local remotes = tracerRemoteMapping[view]
        if remotes then
            for _, rem in ipairs(remotes) do
                if name == rem then
                    local cam = Workspace.CurrentCamera
                    if cam then
                        spawnBulletTrail(cam.CFrame, view)
                    end
                    break
                end
            end
        end
    end
    return oldNamecall(self, ...)
end)
setreadonly(mt, true)
local thirdPersonConnection = nil
local function RenderSteppedModifi()
    local Camera = Workspace.CurrentCamera
    local PlayerArms = Camera:FindFirstChild("Arms")
    if PlayerArms then
        for _, part in ipairs(PlayerArms:GetDescendants()) do
            if part:IsA("BasePart") or part:IsA("MeshPart") then
                if part.Name == "StatClock" then 
                    part:ClearAllChildren()
                end
                part.Transparency = 1
            end
        end
    end
    LocalPlayer.CameraMaxZoomDistance = _G.Settings.ThirdPerson.Distance
    LocalPlayer.CameraMinZoomDistance = _G.Settings.ThirdPerson.Distance
end
_G.ToggleThirdPerson = function(state)
    _G.Settings.ThirdPerson.Enabled = state
    local Camera = Workspace.CurrentCamera
    if state then
        captureOriginalCamera()
        if _G.Settings.ThirdPerson.View == "Default" then
            if thirdPersonConnection then
                thirdPersonConnection:Disconnect()
                thirdPersonConnection = nil
            end
            LocalPlayer.CameraMaxZoomDistance = _G.Settings.ThirdPerson.Distance
            LocalPlayer.CameraMinZoomDistance = 0.5
        elseif _G.Settings.ThirdPerson.View == "Modifi" then
            if not thirdPersonConnection then
                thirdPersonConnection = RunService.RenderStepped:Connect(RenderSteppedModifi)
            end
        end
    else
        if thirdPersonConnection then
            thirdPersonConnection:Disconnect()
            thirdPersonConnection = nil
        end
        if origCameraSettings.captured then
            LocalPlayer.CameraMaxZoomDistance = origCameraSettings.MaxZoom or LocalPlayer.CameraMaxZoomDistance
            LocalPlayer.CameraMinZoomDistance = origCameraSettings.MinZoom or LocalPlayer.CameraMinZoomDistance
            LocalPlayer.CameraMode = origCameraSettings.Mode or LocalPlayer.CameraMode
        else
            LocalPlayer.CameraMaxZoomDistance = 12.5
            LocalPlayer.CameraMinZoomDistance = 0.5
        end
    end
end
_G.SetThirdPersonView = function(value)
    _G.Settings.ThirdPerson.View = value
    if _G.Settings.ThirdPerson.Enabled then
        _G.ToggleThirdPerson(true)
    end
end
_G.ToggleBulletTracer = function(state)
    _G.Settings.BulletTracer.Enabled = state
end
_G.SetBulletTracerView = function(value)
    _G.Settings.BulletTracer.View = value
end
_G.UpdateBulletTracerProperties = function()
end
local OriginalFOV = 70
if Workspace.CurrentCamera then
    OriginalFOV = Workspace.CurrentCamera.FieldOfView
end
_G.FovCustomEnabled = false
_G.FovRemovalValue = _G.Settings.FovCustom.Value
_G.FovConnection = nil
_G.ToggleFovCustom = function(state)
    local CameraLocal = Workspace.CurrentCamera
    _G.FovCustomEnabled = state
    if state then
        captureOriginalCamera()
        if _G.FovConnection then
            _G.FovConnection:Disconnect()
            _G.FovConnection = nil
        end
        _G.FovRemovalValue = _G.Settings.FovCustom.Value
        _G.FovConnection = CameraLocal:GetPropertyChangedSignal("FieldOfView"):Connect(function()
            if _G.FovCustomEnabled and CameraLocal.FieldOfView ~= _G.FovRemovalValue then
                CameraLocal.FieldOfView = _G.FovRemovalValue
            end
        end)
        CameraLocal.FieldOfView = _G.FovRemovalValue
    else
        if _G.FovConnection then
            _G.FovConnection:Disconnect()
            _G.FovConnection = nil
        end
        if origCameraSettings.captured and CameraLocal then
            CameraLocal.FieldOfView = origCameraSettings.FOV or CameraLocal.FieldOfView
        else
            CameraLocal.FieldOfView = OriginalFOV
        end
    end
end
_G.Resolution = _G.Settings.Scrench.Resolution
_G.ScrenchEnabled = false
_G.screnchConnection = nil
_G.toggleScrench = function(state)
    _G.ScrenchEnabled = state
    if state then
        if _G.screnchConnection then
            _G.screnchConnection:Disconnect()
            _G.screnchConnection = nil
        end
        _G.screnchConnection = RunService.RenderStepped:Connect(function()
            local cam = Workspace.CurrentCamera
            if cam then
                cam.CFrame = cam.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, _G.Resolution, 0, 0, 0, 1)
            end
        end)
    else
        if _G.screnchConnection then
            _G.screnchConnection:Disconnect()
            _G.screnchConnection = nil
        end
    end
end
local function onCharacterAdded(character)
    if _G.Settings.ChinaHat.Enabled then
        local head = character:WaitForChild("Head", 5)
        if head then
            _G.createHat(head)
        end
    end
    if _G.Settings.Trails.Enabled then
        _G.initializeTrails(character)
    end
    if _G.Settings.ThirdPerson.Enabled then
        task.wait(0.1)
        _G.ToggleThirdPerson(true)
    end
end
Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
if Players.LocalPlayer.Character then
    onCharacterAdded(Players.LocalPlayer.Character)
end
local materialMap = {
    ["Neon"] = Enum.Material.Neon,
    ["ForceField"] = Enum.Material.ForceField,
    ["Glow"] = Enum.Material.SmoothPlastic
}
local function applyMaterialToPart(part, material, color)
    if part and part:IsA("BasePart") then
        part.Material = material
        part.Color = color
        if material == Enum.Material.SmoothPlastic then
            part.Reflectance = 0.4
        else
            part.Reflectance = 0
        end
    end
end
local function applyWeaponMaterial()
    if not _G.Settings.WeaphonMaterial.Enabled then return end
    local material = materialMap[_G.Settings.WeaphonMaterial.Material]
    if not material then return end
    local color = _G.Settings.WeaphonMaterial.Color
    if _G.Settings.WeaphonMaterial.RGB then
        color = Color3.fromHSV(tick() % 5 / 5, 1, 1)
    end
    local lplayer = LocalPlayer
    local camera = Workspace.CurrentCamera
    if _G.Settings.WeaphonMaterial.View == "Default" then
        if camera then
            for _, obj in ipairs(camera:GetChildren()) do
                if obj:IsA("Model") or obj:IsA("Tool") then
                    for _, part in ipairs(obj:GetDescendants()) do
                        if part:IsA("BasePart") then
                             applyMaterialToPart(part, material, color)
                        end
                    end
                end
            end
        end
        if lplayer.Character then
            for _, tool in ipairs(lplayer.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    for _, part in ipairs(tool:GetDescendants()) do
                         if part:IsA("BasePart") then
                             applyMaterialToPart(part, material, color)
                        end
                    end
                end
            end
        end
    elseif _G.Settings.WeaphonMaterial.View == "Counter Blox" then
        if camera and camera:FindFirstChild("Arms") then
            for _, part in ipairs(camera.Arms:GetDescendants()) do
                 if part:IsA("MeshPart") then
                    local name = part.Name:lower()
                    if not (name:find("arms") or name:find("armleft") or name:find("left arm")) then
                        part.TextureID = ""
                        applyMaterialToPart(part, material, color)
                        part.Transparency = 0
                    end
                 end
            end
        end
    end
end
local function applyPlayerMaterial()
    if not _G.Settings.PlayerMaterial.Enabled then return end
    local material = materialMap[_G.Settings.PlayerMaterial.Material]
    if not material then return end
    local color = _G.Settings.PlayerMaterial.Color
    local lplayer = LocalPlayer
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= lplayer and player.Character then
            local apply = true
            if _G.Settings.PlayerMaterial.TeamCheck then
                if player.Team and lplayer.Team and player.Team == lplayer.Team then
                    apply = false
                end
            end
            if apply then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        applyMaterialToPart(part, material, color)
                    end
                end
            end
        end
    end
end
RunService.RenderStepped:Connect(function()
    applyWeaponMaterial()
    applyPlayerMaterial()
end)
return _G
